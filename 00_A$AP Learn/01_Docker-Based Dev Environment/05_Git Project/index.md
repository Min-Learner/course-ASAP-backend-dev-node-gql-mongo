### Git - the Ultimate Dev Source Code Managament (SCM) System 

The key difference between Git and traditional SCMs is that the concept of "checkout" doesn't mean locking of the code or branch from editing by another Dev. More so, Git does not have a locking mechanism, so anyone can edit any code an any time, and the control happens at the last moment only - when the code is "pushed" into the "remote repository". This may cause a huge problem for a legacy Dev who doesn't understand the Git philosophy and process.

Git has been designed for the work style of "Open Source", loosely managed teams, where the only capability the "owner" or "maintainer" of the code has is to control what he/she physically puts into the master version of the code. Anyone can branch out the code at any point, work on it for as long as it takes, and then (in theory) create a Pull Request (PR) for the owner/maintainer to review the changes and merge (or not) into the master code. And Git has pretty good auto-merging tools that review line-level changes for each file in scope and combine changes that do not overlap. However, if things overlap - the manual merge process can be long and confusing. There is also a concept of "commits" that complicates the flow for an unfamiliar user. The changes are always merged in groups of commits - so if anything can't be auto-merged, the entire commit is not merged, which makes a perfect sense if viewing a commit as a firmly related set of changes: you either put them all in or none, to keep the code logically clean. In reality, one would commit at milestones as well as at the end of the day, before transporting the laptop with unsaved code, so the process has to be taken with enough doze of understanding. The best, of course, is to apply reasonable controls outside the git flow to avoid stepping on each other's work: maintain code separation, use different branches for daily work and merge frequently, while changes and overlaps are relatively minor. Also, "linting" becomes critical so that everyone maintains the same indentation and overall coding style, as any changes in any characters signal a merge process to Git, regardless if the code was actually updated or just reformatted.

You can "fork" any repository into your own one, which creates a copy as-is, with the entire commit history, or you can simply bring just the latest code over to your local machine and start your repository - whatever you prefer. 

Take our quick Git and GitHub ExlSkills Free Course! You have got to get comfortable with Git if you want to be a dev these days, no questions asked. 
